/**
 * This file is autogenerated and should not be modified.
 * Last modified: Wed Feb 25 2026 22:39:45 GMT-0800 (Pacific Standard Time)
 */
import CopyWebpackPlugin from "copy-webpack-plugin";
import webpack from "webpack";
import browserslist from "browserslist";
import MiniCssExtractPlugin from "mini-css-extract-plugin";
import { basename, dirname, relative, resolve, sep } from "path";
import TerserPlugin from "terser-webpack-plugin";
import { realpathSync } from "fs";
import DependencyExtractionWebpackPlugin from "@wordpress/dependency-extraction-webpack-plugin";
import postcssPlugins from "@wordpress/postcss-plugins-preset";
import { createRequire } from "module";
import { getArgVal } from "./lib/args.js";
import {
  PhpFilePathsPlugin,
  getBlockJsonScriptFields,
  getBlockJsonModuleFields,
  fromProjectRoot,
  getProjectSourcePath,
} from "./lib/utils.js";

const isProduction = getArgVal("mode", "development") === "production";
const hasReactFastRefresh = !isProduction;
const require = createRequire(import.meta.url);
const externals = getArgVal("externals", true);

export default {
  mode: "development",
  target: browserslist.findConfig(".")
    ? browserslist.findConfig(".")
    : "browserslist:extends @wordpress/browserslist-config",
  output: {
    filename: "[name].js",
    chunkFilename: "[name].js?ver=[chunkhash]",
    path: resolve(process.cwd(), "build"),
    clean: { keep: /^(fonts|images)\// },
  },
  resolve: {
    alias: { "lodash-es": "lodash" },
    extensions: [".jsx", ".ts", ".tsx", "..."],
  },
  optimization: {
    concatenateModules: false,
    runtimeChunk: false,
    splitChunks: {
      cacheGroups: {
        style: {
          type: "css/mini-extract",
          test: /[\\/]style(\.module)?\.(pc|sc|sa|c)ss$/,
          chunks: "all",
          enforce: true,
          name(_, chunks, cacheGroupKey) {
            const chunkName = chunks[0].name;
            return `${dirname(
              chunkName,
            )}/${cacheGroupKey}-${basename(chunkName)}`;
          },
        },
        default: false,
      },
    },
    minimizer: [
      new TerserPlugin({
        extractComments: false,
        parallel: true,
        terserOptions: {
          output: { comments: /translators:/i },
          compress: { passes: 2 },
          mangle: { reserved: ["__", "_n", "_nx", "_x"] },
        },
      }),
    ],
  },
  module: {
    rules: [
      {
        test: /\.(j|t)sx?$/,
        exclude: [/node_modules/],
        use: require.resolve("source-map-loader"),
        enforce: "pre",
      },
      {
        test: /\.m?(j|t)sx?$/,
        exclude: /node_modules/,
        use: [
          {
            loader: require.resolve("thread-loader"),
            options: { workers: -1 },
          },
          {
            loader: require.resolve("babel-loader"),
            options: {
              presets: [require.resolve("@wordpress/babel-preset-default")],
              plugins: [
                "@babel/plugin-transform-class-properties",
                require.resolve("react-refresh/babel"),
              ],
            },
          },
        ],
      },
      {
        test: /\.css$/,
        use: [
          { loader: MiniCssExtractPlugin.loader },
          {
            loader: require.resolve("css-loader"),
            options: {
              importLoaders: 1,
              sourceMap: true,
              modules: { auto: true },
            },
          },
          {
            loader: require.resolve("postcss-loader"),
            options: {
              postcssOptions: {
                ident: "postcss",
                sourceMap: true,
                plugins: postcssPlugins,
              },
            },
          },
        ],
      },
      {
        test: /\.pcss$/,
        use: [
          { loader: MiniCssExtractPlugin.loader },
          {
            loader: require.resolve("css-loader"),
            options: {
              importLoaders: 1,
              sourceMap: true,
              modules: { auto: true },
            },
          },
          {
            loader: require.resolve("postcss-loader"),
            options: {
              postcssOptions: {
                ident: "postcss",
                sourceMap: true,
                plugins: postcssPlugins,
              },
            },
          },
        ],
      },
      {
        test: /\.(sc|sa)ss$/,
        use: [
          { loader: MiniCssExtractPlugin.loader },
          {
            loader: require.resolve("css-loader"),
            options: {
              importLoaders: 1,
              sourceMap: true,
              modules: { auto: true },
            },
          },
          {
            loader: require.resolve("postcss-loader"),
            options: {
              postcssOptions: {
                ident: "postcss",
                sourceMap: true,
                plugins: postcssPlugins,
              },
            },
          },
          {
            loader: require.resolve("sass-loader"),
            options: {
              sourceMap: true,
              sassOptions: {
                silenceDeprecations: [
                  "global-builtin",
                  "import",
                  "color-functions",
                  "if-function",
                ],
              },
            },
          },
        ],
      },
      {
        test: /\.svg$/,
        issuer: /\.(j|t)sx?$/,
        use: ["@svgr/webpack", "url-loader"],
        type: "javascript/auto",
      },
      {
        test: /\.svg$/,
        type: "asset/resource",
        generator: { filename: "fonts/[name][ext]" },
      },
      {
        test: /\.(bmp|png|jpe?g|gif|webp)$/i,
        type: "asset/resource",
        generator: { filename: "images/[name][ext]" },
      },
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/i,
        type: "asset/resource",
        generator: { filename: "fonts/[name][ext]" },
      },
    ],
  },
  stats: { children: false },
  devtool: "source-map",
  entry: {
    frontend:
      "/Users/dannyguzman/Development/CAWebPublishing/webpack/src/frontend.js",
    index:
      "/Users/dannyguzman/Development/CAWebPublishing/webpack/src/index.js",
  },
  plugins: [
    new webpack.DefinePlugin({
      "globalThis.SCRIPT_DEBUG": true,
      SCRIPT_DEBUG: true,
    }),
    new PhpFilePathsPlugin({ context: "src", props: ["render", "variations"] }),
    new CopyWebpackPlugin({
      patterns: [
        {
          from: "**/block.json",
          context: "src",
          noErrorOnMissing: true,
          transform(content, absoluteFrom) {
            const convertExtension = (path) => {
              return path.replace(/\.m?(j|t)sx?$/, ".js");
            };

            if (basename(absoluteFrom) === "block.json") {
              const blockJson = JSON.parse(content.toString());

              [
                getBlockJsonScriptFields(blockJson),
                getBlockJsonModuleFields(blockJson),
              ].forEach((fields) => {
                if (fields) {
                  for (const [key, value] of Object.entries(fields)) {
                    if (Array.isArray(value)) {
                      blockJson[key] = value.map(convertExtension);
                    } else if (typeof value === "string") {
                      blockJson[key] = convertExtension(value);
                    }
                  }
                }
              });

              if (hasReactFastRefresh) {
                // Prepends the file reference to the shared runtime chunk to every script type defined for the block.
                const runtimePath = relative(
                  dirname(absoluteFrom),
                  fromProjectRoot(getProjectSourcePath() + sep + "runtime.js"),
                );
                const fields = getBlockJsonScriptFields(blockJson);
                for (const [fieldName] of Object.entries(fields)) {
                  blockJson[fieldName] = [
                    `file:${runtimePath}`,
                    ...(Array.isArray(blockJson[fieldName])
                      ? blockJson[fieldName]
                      : [blockJson[fieldName]]),
                  ];
                }
              }

              return JSON.stringify(blockJson, null, 2);
            }

            return content;
          },
        },
        {
          from: "**/*.php",
          context: "src",
          noErrorOnMissing: true,
          filter: (filepath) => {
            return (
              process.env.WP_COPY_PHP_FILES_TO_DIST ||
              PhpFilePathsPlugin.paths.includes(
                realpathSync(filepath).replace(/\\/g, "/"),
              )
            );
          },
        },
      ],
      options: {},
    }),
    new MiniCssExtractPlugin({
      filename: isProduction ? "[name].min.css" : "[name].css",
    }),
    externals && new DependencyExtractionWebpackPlugin(),
  ],
};
